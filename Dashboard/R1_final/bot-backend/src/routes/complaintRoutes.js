const express = require('express');
const router = express.Router();
const { v4: uuidv4 } = require('uuid');

// In-memory storage for auto-generated complaints
const autoComplaints = [];

/**
 * @route   POST /api/complaints/auto-generate
 * @desc    Create auto-generated complaint from CCTV detection
 * @access  Public
 */
router.post('/auto-generate', async (req, res) => {
  try {
    const {
      type,
      description,
      screenshot,
      timestamp,
      location,
      priority,
      detectedPerson,
      evidence,
      safetyRating,
    } = req.body;

    const complaint = {
      id: uuidv4(),
      type: type || 'Littering',
      description,
      screenshot,
      timestamp: timestamp || new Date().toISOString(),
      location: location || 'CCTV Camera Location',
      status: 'pending',
      priority: priority || 'high',
      detectedPerson,
      evidence,
      safetyRating: safetyRating || 3, // Default unsafe rating
      autoGenerated: true,
      reviewed: false,
      assignedWorker: null,
      createdAt: new Date().toISOString(),
    };

    autoComplaints.unshift(complaint);

    // Keep only last 100 complaints
    if (autoComplaints.length > 100) {
      autoComplaints.pop();
    }

    // Emit socket event to dashboard
    if (req.app.get('io')) {
      req.app.get('io').emit('new_auto_complaint', complaint);
    }

    res.json({
      success: true,
      message: 'Auto-complaint created successfully',
      data: complaint,
    });
  } catch (error) {
    console.error('Error creating auto-complaint:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating auto-complaint',
      error: error.message,
    });
  }
});

/**
 * @route   GET /api/complaints/auto
 * @desc    Get all auto-generated complaints
 * @access  Public
 */
router.get('/auto', async (req, res) => {
  try {
    const { status, priority, limit = 50 } = req.query;

    let filteredComplaints = autoComplaints;

    if (status) {
      filteredComplaints = filteredComplaints.filter(
        (complaint) => complaint.status === status
      );
    }

    if (priority) {
      filteredComplaints = filteredComplaints.filter(
        (complaint) => complaint.priority === priority
      );
    }

    const limitedComplaints = filteredComplaints.slice(0, parseInt(limit));

    res.json({
      success: true,
      data: limitedComplaints,
      total: filteredComplaints.length,
    });
  } catch (error) {
    console.error('Error fetching auto-complaints:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching auto-complaints',
      error: error.message,
    });
  }
});

/**
 * @route   PATCH /api/complaints/auto/:id
 * @desc    Update auto-generated complaint
 * @access  Public
 */
router.patch('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const complaintIndex = autoComplaints.findIndex((c) => c.id === id);

    if (complaintIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Complaint not found',
      });
    }

    autoComplaints[complaintIndex] = {
      ...autoComplaints[complaintIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    // Emit socket event
    if (req.app.get('io')) {
      req.app.get('io').emit('complaint_updated', autoComplaints[complaintIndex]);
    }

    res.json({
      success: true,
      message: 'Complaint updated successfully',
      data: autoComplaints[complaintIndex],
    });
  } catch (error) {
    console.error('Error updating complaint:', error);
    res.status(500).json({
      success: false,
      message: 'Error updating complaint',
      error: error.message,
    });
  }
});

/**
 * @route   POST /api/complaints/auto/:id/assign
 * @desc    Assign auto-generated complaint to worker
 * @access  Public
 */
router.post('/:id/assign', async (req, res) => {
  try {
    const { id } = req.params;
    const { workerId, workerName } = req.body;

    const complaintIndex = autoComplaints.findIndex((c) => c.id === id);

    if (complaintIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Complaint not found',
      });
    }

    autoComplaints[complaintIndex] = {
      ...autoComplaints[complaintIndex],
      status: 'assigned',
      assignedWorker: {
        id: workerId,
        name: workerName,
        assignedAt: new Date().toISOString(),
      },
      updatedAt: new Date().toISOString(),
    };

    // Emit socket events
    if (req.app.get('io')) {
      req.app.get('io').emit('complaint_assigned', autoComplaints[complaintIndex]);
      req.app.get('io').emit(`worker_notification_${workerId}`, {
        type: 'new_complaint',
        message: 'New auto-generated complaint assigned to you',
        complaint: autoComplaints[complaintIndex],
      });
    }

    res.json({
      success: true,
      message: 'Complaint assigned successfully',
      data: autoComplaints[complaintIndex],
    });
  } catch (error) {
    console.error('Error assigning complaint:', error);
    res.status(500).json({
      success: false,
      message: 'Error assigning complaint',
      error: error.message,
    });
  }
});

/**
 * @route   DELETE /api/complaints/auto/:id
 * @desc    Delete auto-generated complaint
 * @access  Public
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const complaintIndex = autoComplaints.findIndex((c) => c.id === id);

    if (complaintIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Complaint not found',
      });
    }

    autoComplaints.splice(complaintIndex, 1);

    res.json({
      success: true,
      message: 'Complaint deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting complaint:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting complaint',
      error: error.message,
    });
  }
});

module.exports = router;
